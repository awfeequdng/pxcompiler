
%{
  #include <cstdlib>

  #include "common/colorizer.h"
  #include "common/check.h"
  #include "common/error.h"
  #include "parser/flex_bison/lex_helper.h"
  #include "parser/flex_bison/lex_scan_helper.h"
  #include "parser/flex_bison/parse_and_lex_context.h"
  #include "parser/flex_bison/parser.h"
  #include "llvm/ADT/StringExtras.h"
  #include <fmt/format.h>
%}

/* Turn off legacy bits we don't need. */
%option noyywrap nodefault

%option reentrant

%x NORMAL

/* table-begin */
FALSE                "False"
TRUE                 "True"
NONE                 "None"
AND                  "and"
AS                   "as"
ASSERT               "assert"
ASYNC                "async"
AWAIT                "await"
BREAK                "break"
CLASS                "class"
CONTINUE             "continue"
DEF                  "def"
DEL                  "del"
ELIF                 "elif"
ELSE                 "else"
EXCEPT               "except"
FINALLY              "finally"
FOR                  "for"
FROM                 "from"
GLOBAL               "global"
IF                   "if"
IMPORT               "import"
IN                   "in"
IS                   "is"
LAMBDA               "lambda"
NONLOCAL             "nonlocal"
NOT                  "not"
OR                   "or"
PASS                 "pass"
RETURN               "return"
TRY                  "try"
WHILE                "while"
WITH                 "with"
YIELD                "yield"

ARROW                "->"
AMPERSAND            "&"
COLON                ":"
COLON_BANG           ":!"
COMMA                ","
DOUBLE_ARROW         "=>"
EQUAL                "="
EQUAL_EQUAL          "=="

LBRACE     "{"
LPARENT     "("
LBRACKET  "["

MINUS                "-"
PERIOD               "."
PLUS                 "+"

RBRACE                "}"
RPARENT               ")"
RBRACKET              "]"

SELF                 "self"
SEMICOLON            ";"
SLASH                "/"
UNDERSCORE           "_"
/* table-end */

/* This should be kept table-like, but isn't automatic due to spaces. */
identifier            [A-Za-z_][A-Za-z0-9_]*
/* TODO: Remove Print special casing once we have variadics or overloads. */
sized_type_literal    [iuf][1-9][0-9]*
integer_literal       [0-9]+
horizontal_whitespace [ \t\r]
whitespace            [ \t\r\n]
one_line_comment      \#[^\n]*\n
operand_start         [(A-Za-z0-9_\"]

%%

%{
  // Code run each time yylex is called.
  // Begin with an empty token span starting where its previous end was.
  context.current_token_position.step();
%}
" " {
    context.current_token_position.step();
    context.current_line_indent++;
  }
"\t" {
    // tab act as 4 space
    context.current_token_position.step();
    context.current_line_indent = (context.current_line_indent + 4) & ~3;
  }
"\n" {
    auto tok = PXC_TOKEN(NEWLINE);
    context.current_token_position.lines(1);
    context.current_token_position.step();
    context.current_line_indent = 0;
    return tok;
  }

. {
    unput(*yytext);
    size_t indent_level = context.indent_stk.top();
    if (context.current_line_indent > indent_level) {
      context.indent_stk.push(context.current_line_indent);
      BEGIN(NORMAL);
      std::cout << "begin normal, indent" << std::endl;
      return PXC_TOKEN(INDENT);
    } else if (context.current_line_indent < indent_level) {
      context.indent_stk.pop();
      indent_level = context.indent_stk.top();
      if (context.current_line_indent > indent_level) {
          return context.RecordSyntaxError(
            pxcompiler::colorizer::colorize("Error:",
                                            pxcompiler::term_colors_t::red) +
            fmt::format("illegal indentation:{0}, level:{1}\n",
                        context.current_line_indent,
                        indent_level));
      }
      std::cout << "dedent" << std::endl;
      return PXC_TOKEN(DEDENT);
    } else {
      std::cout << "begin normal" << std::endl;
      BEGIN(NORMAL);
    }
  }

<<EOF>> {
    size_t indent_level = context.indent_stk.top();
    auto warn = fmt::format("eof at line %d: indentation %d %d\n",
                  context.current_token_position.begin.line,
                  context.current_line_indent, indent_level);
    std::cout << "eof: " << warn << std::endl;
    if (indent_level > 0) {
        context.indent_stk.pop();
        std::cout << "dedent" << std::endl;
        return PXC_TOKEN(DEDENT);
    }
    return PXC_TOKEN(END_OF_FILE);
  }

<NORMAL>{

  /* table-begin */

  {FALSE}                     { return PXC_TOKEN(FALSE);                }
  {TRUE}                      { return PXC_TOKEN(TRUE);                 }
  {NONE}                      { return PXC_TOKEN(NONE);                 }
  {AND}                       { return PXC_TOKEN(AND);                  }
  {AS}                        { return PXC_TOKEN(AS);                   }
  {ASSERT}                    { return PXC_TOKEN(ASSERT);               }
  {ASYNC}                     { return PXC_TOKEN(ASYNC);                }
  {AWAIT}                     { return PXC_TOKEN(AWAIT);                }
  {BREAK}                     { return PXC_TOKEN(BREAK);                }
  {CLASS}                     { return PXC_TOKEN(CLASS);                }
  {CONTINUE}                  { return PXC_TOKEN(CONTINUE);             }
  {DEF}                       { return PXC_TOKEN(DEF);                  }
  {DEL}                       { return PXC_TOKEN(DEL);                  }
  {ELIF}                      { return PXC_TOKEN(ELIF);                 }
  {ELSE}                      { return PXC_TOKEN(ELSE);                 }
  {EXCEPT}                    { return PXC_TOKEN(EXCEPT);               }
  {FINALLY}                   { return PXC_TOKEN(FINALLY);              }
  {FOR}                       { return PXC_TOKEN(FOR);                  }
  {FROM}                      { return PXC_TOKEN(FROM);                 }
  {GLOBAL}                    { return PXC_TOKEN(GLOBAL);               }
  {IF}                        { return PXC_TOKEN(IF);                   }
  {IMPORT}                    { return PXC_TOKEN(IMPORT);               }
  {IN}                        { return PXC_TOKEN(IN);                   }
  {IS}                        { return PXC_TOKEN(IS);                   }
  {LAMBDA}                    { return PXC_TOKEN(LAMBDA);               }
  {NONLOCAL}                  { return PXC_TOKEN(NONLOCAL);             }
  {NOT}                       { return PXC_TOKEN(NOT);                  }
  {OR}                        { return PXC_TOKEN(OR);                   }
  {PASS}                      { return PXC_TOKEN(PASS);                 }
  {RETURN}                    { return PXC_TOKEN(RETURN);               }
  {TRY}                       { return PXC_TOKEN(TRY);                  }
  {WHILE}                     { return PXC_TOKEN(WHILE);                }
  {WITH}                      { return PXC_TOKEN(WITH);                 }
  {YIELD}                     { return PXC_TOKEN(YIELD);                }

  {ARROW}                     { return PXC_TOKEN(ARROW);                }
  {AMPERSAND}                 { return PXC_TOKEN(AMPERSAND);            }
  {COLON}                     { return PXC_TOKEN(COLON);                }
  {COLON_BANG}                { return PXC_TOKEN(COLON_BANG);           }
  {COMMA}                     { return PXC_TOKEN(COMMA);                }
  {DOUBLE_ARROW}              { return PXC_TOKEN(DOUBLE_ARROW);         }
  {EQUAL}                     { return PXC_TOKEN(EQUAL);                }
  {EQUAL_EQUAL}               { return PXC_TOKEN(EQUAL_EQUAL);          }
  {LBRACE}                    { return PXC_TOKEN(LBRACE);     }
  {LPARENT}                   { return PXC_TOKEN(LPARENT);     }
  {LBRACKET}                  { return PXC_TOKEN(LBRACKET);  }

  {MINUS}                     { return PXC_TOKEN(MINUS);                }
  {PERIOD}                    { return PXC_TOKEN(PERIOD);               }
  {PLUS}                      { return PXC_TOKEN(PLUS);                 }
  {SELF}                      { return PXC_TOKEN(SELF);                 }
  {SEMICOLON}                 { return PXC_TOKEN(SEMICOLON);            }
  {SLASH}                     { return PXC_TOKEN(SLASH);                }
  {UNDERSCORE}                { return PXC_TOKEN(UNDERSCORE);           }
  /* table-end */

  {RPARENT} {
    return PXC_TOKEN(RPARENT);
  }
  {RBRACE} {
    return PXC_TOKEN(RBRACE);
  }
  {RBRACKET} {
    return PXC_TOKEN(RBRACKET);
  }

  /*
    * For a `*` operator, we look at whitespace and local context to determine the
    * arity and fixity. There are two ways to write a binary operator:
    *
    * 1) Whitespace on both sides.
    * 2) Whitespace on neither side, and the previous token is considered to be
    *    the end of an operand, and the next token is considered to be the start
    *    of an operand.
    *
    * Otherwise, the operator is unary, but we also check for whitespace to help
    * the parser enforce the rule that whitespace is not permitted between the
    * operator and its operand, leading to three more cases:
    *
    * 3) Whitespace before (but implicitly not after, because that would give a
    *    longer match and hit case 1): this can only be a prefix operator.
    * 4) Whitespace after and not before: this can only be a postfix operator.
    * 5) No whitespace on either side (otherwise the longest match would take us
    *    to case 4): this is a unary operator and could be either prefix or
    *    postfix.
    */

  {sized_type_literal} {
    return PXC_ARG_TOKEN(sized_type_literal, yytext);
  }

  {identifier} {
    return PXC_ARG_TOKEN(identifier, yytext);
  }

  {integer_literal} {
    long long val = 0;
    if (!llvm::to_integer(yytext, val)) {
      return context.RecordSyntaxError(
          fmt::format("Invalid integer literal: {0}", yytext));
    }
    return PXC_ARG_TOKEN(integer_literal, val);
  }

  {one_line_comment} {
    auto tok = PXC_TOKEN(COMMENT);
    // Advance end by 1 line, resetting the column to zero.
    context.current_token_position.lines(1);
    // Make the span empty by setting start to end.
    context.current_token_position.step();
    context.current_line_indent = 0;
    BEGIN(INITIAL);
    return tok;
  }

  {horizontal_whitespace} {
    // Make the span empty by setting start to end.
    context.current_token_position.step();
  }

  "\n" {
    // Advance end by yyleng lines, resetting the column to zero.
    auto tok = PXC_TOKEN(NEWLINE);
    context.current_token_position.lines(yyleng);
    // Make the span empty by setting start to end.
    context.current_token_position.step();
    context.current_line_indent = 0;
    BEGIN(INITIAL);
    return tok;
  }

  . {
    return context.RecordSyntaxError(
        fmt::format("invalid character '\\x{0}' in source file.",
                      llvm::toHex(llvm::StringRef(yytext, 1))));
  }

}

%%

auto YyinputWrapper(yyscan_t yyscanner) -> int { return yyinput(yyscanner); }
