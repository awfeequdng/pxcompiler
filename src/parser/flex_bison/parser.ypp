// PEG grammar for Python

// -----------------------------------------------------------------------------
// Bison Configuration
// -----------------------------------------------------------------------------

%require "3.2"
%language "c++"

// We don't need a separate header for Bison locations.
%define api.location.file none

// Use a type-safe C++ variant for semantic values
%define api.value.type variant

// Have Bison generate the functions ‘make_TEXT’ and ‘make_NUMBER’, but also
// ‘make_YYEOF’, for the end of input.
%define api.token.constructor

// Generate the parser as `::pxcompiler::Parser`.
%define api.namespace { pxcompiler }
%define api.parser.class { Parser }

// Enable support for parser debugging
%define parse.trace true

// Generate location structs.
%locations


// Parameters to the parser and lexer.
//
// Parameters to the parser are stored therein as protected data members, and
// thus available to its methods.

// "inout" parameters passed to both the parser and the lexer.
%param {pxcompiler::Nonnull<pxcompiler::Arena*> arena}
%param {yyscan_t yyscanner}
%param {ParseAndLexContext& context}

// "out" parameter passed to the parser, where the AST is written.
%parse-param {std::optional<pxcompiler::ASTPtr>* ast}

%code top {
  #include <algorithm>
  #include <cstdarg>
  #include <cstdio>
  #include <cstdlib>
  #include <vector>
  #include <utility>

  #include "common/check.h"
  #include "parser/flex_bison/parser.h"
  #include "parser/flex_bison/parse_and_lex_context.h"
  #include "llvm/ADT/StringExtras.h"
  #include "llvm/Support/raw_ostream.h"
}  // %code top


%code requires {
  #include <optional>

  #include "ast/ast.h"
  #include "common/arena.h"
  #include "common/nonnull.h"
  #include "parser/flex_bison/semantics.h"
  #include "parser/flex_bison/parser.h"

  namespace pxcompiler {
  class ParseAndLexContext;
  }  // namespace pxcompiler

  typedef void* yyscan_t;
}  // %code requires


%code {
  void pxcompiler::Parser::error(const location_type&, const std::string& message) {
    context.RecordSyntaxError(message);
  }
}  // %code

%token <long long> integer_literal
%token <double> real_literal
%token <double> image_literal
%token <std::string> identifier
%token <std::string> sized_type_literal
%token <std::string> string_literal

%token
  // Most tokens have their spelling defined in lexer.lpp.
  // table-begin
  FALSE
  TRUE
  NONE
  AND
  AS
  ASSERT
  ASYNC
  AWAIT
  BREAK
  CLASS
  CONTINUE
  DEF
  DEL
  ELIF
  ELSE
  EXCEPT
  FINALLY
  FOR
  FROM
  GLOBAL
  IF
  IMPORT
  IN
  IS
  LAMBDA
  NONLOCAL
  NOT
  OR
  PASS
  RETURN
  TRY
  WHILE
  WITH
  YIELD
  ARROW
  AMPERSAND
  COLON           ":"
  COLON_BANG
  COMMA           ","
  DOUBLE_ARROW
  EQUAL
  COLONEQUAL      ":="
  EQUAL_EQUAL
  LBRACE          "{"
  LPARENT         "("
  LBRACKET        "["
  MINUS
  PERIOD          "."
  PLUS
  STAR            "*"
  ELLIPSIS
  RBRACE          "}"
  RPARENT         ")"
  RBRACKET        "]"
  SELF
  SEMICOLON
  SLASH
  UNDERSCORE

  INDENT
  DEDENT
  NEWLINE
  COMMENT
  EOLCOMMENT
  TYPE_COMMENT

  // Used to track EOF.
  END_OF_FILE 0
;

%type <Nonnull<Statement*>> script_unit
%type <Nonnull<Statement*>> statement
%type <Nonnull<Statement*>> expression_statment
%type <Nonnull<Statement*>> single_line_statement
%type <Nonnull<Statement*>> multi_line_statement
%type <Nonnull<Statement*>> if_statement
%type <std::vector<Nonnull<Statement*>>> body_stmts
%type <std::vector<Nonnull<Statement*>>> statements1
%type <std::vector<Nonnull<Statement*>>> statements
%type <std::vector<Nonnull<Statement*>>> sep_statements
%type <std::vector<Nonnull<Statement*>>> single_line_statements
%type <std::vector<Nonnull<Statement*>>> single_line_multi_statements
%type <std::vector<Nonnull<Statement*>>> single_line_multi_statements_opt
%type <Nonnull<Expression*>> expr
%type <std::vector<Nonnull<Expression*>>> expr_list
%type <std::vector<Nonnull<Expression*>>> expr_list_opt
%type <std::vector<PairNonnullExpr>> dict_list
%type <PairNonnullExpr> dict
%type <Nonnull<Name*>> id
%type <Nonnull<Expression*>> string

%type <std::vector<std::string>> sep
%type <std::string> sep_one

// Precedence

%precedence ":="
%left "*"
%precedence "."


%start units

%%
// The order of rules does not matter in Bison (unlike in ANTLR). The
// precedence is specified not by the order but by %left and %right directives
// as well as with %dprec.

// ----------------------------------------------------------------------------
// Top level rules to be used for parsing.

// Higher %dprec means higher precedence
units
    : units script_unit   { RESULT($2); }
    | script_unit         { RESULT($1); }
    | sep
    ;

script_unit
    : statement
    ;

statements
    : INDENT statements1 DEDENT { $$ = $2; }
    ;

sep_statements
    : sep statements { $$ = $2; }
    ;

body_stmts
    : single_line_statements { $$ = $1; }
    | sep_statements { $$ = $1; }
    ;

statements1
    : statements1 statement { $$ = $1; LIST_ADD($$, $2); }
    | statement { LIST_NEW($$); LIST_ADD($$, $1); }
    ;

single_line_statements
    : single_line_multi_statements NEWLINE { $$ = $1; }
    | single_line_multi_statements COMMENT NEWLINE { $$ = $1; }
    | single_line_statement NEWLINE { LIST_NEW($$); LIST_ADD($$, $1); }
    | single_line_statement SEMICOLON NEWLINE {
        LIST_NEW($$); LIST_ADD($$, $1);
      }
    | single_line_statement SEMICOLON COMMENT NEWLINE {
        LIST_NEW($$); LIST_ADD($$, $1);
      }
    | single_line_statement COMMENT NEWLINE {
        LIST_NEW($$); LIST_ADD($$, $1);
      }
    ;

single_line_multi_statements
    : single_line_multi_statements_opt single_line_statement {
        $$ = $1; LIST_ADD($$, $2);
      }
    | single_line_multi_statements_opt single_line_statement SEMICOLON {
        $$ = $1; LIST_ADD($$, $2);
      }
    ;

single_line_multi_statements_opt
    : single_line_multi_statements_opt single_line_statement SEMICOLON {
        $$ = $1; LIST_ADD($$, $2);
      }
    | single_line_statement SEMICOLON {
        LIST_NEW($$); LIST_ADD($$, $1);
      }
    ;

statement
    : single_line_statement sep { $$ = $1; }
    | multi_line_statement
    | multi_line_statement sep { $$ = $1; }
    ;

single_line_statement
    : expression_statment
//    | assert_statement
//    | assignment_statement
//    | augassign_statement
//    | ann_assignment_statement
//    | pass_statement
//    | delete_statement
//    | return_statement
//    | raise_statement
//    | break_statement
//    | continue_statement
//    | import_statement
//    | global_statement
//    | if_statement_single
//    | nonlocal_statement
    ;

multi_line_statement
    : if_statement
//    | for_statement
//    | try_statement
//    | with_statement
//    | function_def
//    | class_def
//    | async_func_def
//    | async_for_stmt
//    | async_with_stmt
//    | while_statement
    ;

if_statement
    : IF expr ":" body_stmts {
        $$ = IF_STMT_01($2, $4, context.source_loc());
      }
    | IF expr ":" body_stmts ELSE ":" body_stmts {
        $$ = IF_STMT_02($2, $4, $7, context.source_loc());
      }
//    | KW_IF expr ":" body_stmts elif_statement {
//        $$ = IF_STMT_03($2, $4, $5, context.source_loc()); }
    ;

expression_statment
    : expr { $$ = EXPR_01($1, context.source_loc()); }
    ;

string
    : string string_literal { $$ = STRING2($1, $2, context.source_loc()); }
    | string_literal {
        $$ = STRING1($1, context.source_loc());
      }
    | id string_literal {
        $$ = STRING3($1, $2, context.source_loc());
      }
    | string id string_literal {
        $$ = STRING4($1, $2, $3, context.source_loc());
      }
    ;

expr_list_opt
    : expr_list { $$ = $1; }
    | %empty { LIST_NEW($$); }
    ;

expr_list
    : expr_list "," expr { $$ = $1; LIST_ADD($$, $3); }
    | expr { LIST_NEW($$); LIST_ADD($$, $1); }
    ;

// expr_list
//    : expr_list "," expr %prec "not" { $$ = $1; LIST_ADD($$, $3); }
//    | expr %prec "not" { LIST_NEW($$); LIST_ADD($$, $1); }
//    ;


dict
    : expr ":" expr { $$ = DICT_EXPR($1, $3, @$); }
    ;

dict_list
    : dict_list "," dict { $$ = $1; LIST_ADD($$, $3); }
    | dict { LIST_NEW($$); LIST_ADD($$, $1); }
    ;


expr
    : id { $$ = $1; }
    | integer_literal {
        std::cout << "integer lit: " << $1 << std::endl;
        $$ = INTEGER($1, context.source_loc());
      }
    | string { $$ = $1; }
    | real_literal { $$ = FLOAT($1, context.source_loc()); }
    | image_literal {
        std::cout << "image_literal: " << $1 << std::endl;
        $$ = COMPLEX($1, context.source_loc());
      }
    | TRUE { $$ = BOOL(true, context.source_loc()); }
    | FALSE { $$ = BOOL(false, context.source_loc()); }
    | NONE { $$ = NONE(context.source_loc()); }
    | ELLIPSIS { $$ = ELLIPSIS(context.source_loc()); }
    | "(" expr ")" { $$ = $2; }
    | "(" ")" { $$ = TUPLE_EMPTY(context.source_loc()); }
   // | function_call { $$ = $1; }
   // | subscription { $$ = $1; }
    | "[" expr_list_opt "]" { $$ = LIST($2, context.source_loc()); }
    | "[" expr_list "," "]" { $$ = LIST($2, context.source_loc()); }
    | "{" expr_list "}" { $$ = SET($2, context.source_loc()); }
    | "{" expr_list "," "}" { $$ = SET($2, context.source_loc()); }
    | expr "." id { $$ = ATTRIBUTE_REF($1, $3, context.source_loc()); }

    | "{" "}" { $$ = DICT_01(context.source_loc()); }
    | "{" dict_list "}" { $$ = DICT_02($2, context.source_loc()); }
   // | KW_AWAIT expr %prec AWAIT { $$ = AWAIT($2, context.source_loc()); }
   // | KW_YIELD %prec YIELD { $$ = YIELD_01(context.source_loc()); }
   // | KW_YIELD expr %prec YIELD { $$ = YIELD_02($2, context.source_loc()); }
    | id ":=" expr { $$ = NAMEDEXPR($1, $3, context.source_loc()); }
    | "*" expr { $$ = STARRED_ARG($2, context.source_loc()); }

   // | expr "+" expr { $$ = BINOP($1, Add, $3, context.source_loc()); }
   // | expr "-" expr { $$ = BINOP($1, Sub, $3, context.source_loc()); }
   // | expr "*" expr { $$ = BINOP($1, Mult, $3, context.source_loc()); }
   // | expr "/" expr { $$ = BINOP($1, Div, $3, context.source_loc()); }
   // | expr "%" expr { $$ = BINOP($1, Mod, $3, context.source_loc()); }
   // | "-" expr %prec UNARY { $$ = UNARY($2, USub, context.source_loc()); }
   // | "+" expr %prec UNARY { $$ = UNARY($2, UAdd, context.source_loc()); }
   // | "~" expr %prec UNARY { $$ = UNARY($2, Invert, context.source_loc()); }
   // | expr "**" expr { $$ = BINOP($1, Pow, $3, context.source_loc()); }
   // | expr "//" expr { $$ = BINOP($1, FloorDiv, $3, context.source_loc()); }
   // | expr "@" expr { $$ = BINOP($1, MatMult, $3, context.source_loc()); }

   // | expr "&" expr { $$ = BINOP($1, BitAnd, $3, context.source_loc()); }
   // | expr "|" expr { $$ = BINOP($1, BitOr, $3, context.source_loc()); }
   // | expr "^" expr { $$ = BINOP($1, BitXor, $3, context.source_loc()); }
   // | expr "<<" expr { $$ = BINOP($1, LShift, $3, context.source_loc()); }
   // | expr ">>" expr { $$ = BINOP($1, RShift, $3, context.source_loc()); }

   // | expr "==" expr { $$ = COMPARE($1, Eq, $3, context.source_loc()); }
   // | expr "!=" expr { $$ = COMPARE($1, NotEq, $3, context.source_loc()); }
   // | expr "<" expr { $$ = COMPARE($1, Lt, $3, context.source_loc()); }
   // | expr "<=" expr { $$ = COMPARE($1, LtE, $3, context.source_loc()); }
   // | expr ">" expr { $$ = COMPARE($1, Gt, $3, context.source_loc()); }
   // | expr ">=" expr { $$ = COMPARE($1, GtE, $3, context.source_loc()); }
   // | expr "is" expr { $$ = COMPARE($1, Is, $3, context.source_loc()); }
   // | expr "is not" expr { $$ = COMPARE($1, IsNot, $3, context.source_loc()); }
   // | expr "in" expr { $$ = COMPARE($1, In, $3, context.source_loc()); }
   // | expr "not in" expr { $$ = COMPARE($1, NotIn, $3, context.source_loc()); }

   // | expr "and" expr { $$ = BOOLOP($1, And, $3, context.source_loc()); }
   // | expr "or" expr { $$ = BOOLOP($1, Or, $3, context.source_loc()); }
   // | "not" expr { $$ = UNARY($2, Not, context.source_loc()); }

   // // Comprehension
   // | "[" expr comp_for_items "]" { $$ = LIST_COMP_1($2, $3, context.source_loc()); }
   // | "{" expr comp_for_items "}" { $$ = SET_COMP_1($2, $3, context.source_loc()); }
   // | "{" expr ":" expr comp_for_items "}" { $$ = DICT_COMP_1($2, $4, $5, context.source_loc()); }

   // | ternary_if_statement { $$ = $1; }
   // | lambda_expression { $$ = $1; }
    ;

id
    : identifier { $$ = SYMBOL($1, context.source_loc()); }
    ;

sep
    : sep sep_one { $$ = $1; LIST_ADD($$, $2); }
    | sep_one { LIST_NEW($$); LIST_ADD($$, $1); }
    ;

sep_one
    : NEWLINE { $$ = std::string("newline"); }
    | COMMENT { $$ = std::string("comment"); }
    | SEMICOLON { $$ = std::string(";"); }
    ;

%%